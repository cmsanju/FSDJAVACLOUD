		   ::JAVA::
Introduction:
=============
1.Definition of Software:
------------------------
Collection of programmes meant for performing some specific operations is known as Software.

	In real industry we have lot of operations and those operations are classified into 3 types for the simplicity of the programmers.
	
	Classifications of operations are nothing but classifying the softwares. 
they are          	1.System Software
		 		2.Application Software
				3.Internet Software
1.System Software:
------------------
The aim of system software is developing the s/w or projects for the computers. 

1.Development of device drivers: 
(s/w for printers, scanners, tablet etc).
2.Development of language compilers:
(s/w for interpreters, loaders, assemblers etc).
3.Development of real time operating systems (RTO'S):
(s/w for unix, linux, Solaris, windows OS's).

2.Application software:
-----------------------
The aim of application software is developing the s/w or projects for the organisations.
	some of the organisations for financial sector Banking, insurance and etc.
1. Health care sector(Hospitality services, Diagnostics etc).
2. Transportation services(air lines, railways etc).
3. educational sector(schools, colleges and etc).
4. super markets(Shopping malls).

in real industry to develop app's software for the organisations we have two types of technologies they are.
	1. Front end technologies
	2. Back end technologies
3. Internet Software:
---------------------
The purpose of internet s/w is  to develop distributed apps 
	to develop distributed apps in real industry we have the following languages / technologies 
a. java developed at sun-micro systems INC USA(Oracle Corporation).
b. dot net(.net) developed at Microsoft INC USA 

	hence java is one of the internet s/w developed at sun-micro systems released to the real industry and used by all the programmers for development of every apps and it is more popular for developing distributed apps.

* Architecture required for developing distributed apps:

  in real world to develop any distributed apps we follow a well known architecture called client server architecture and it is available in three categories they are.

a. 2-tier architecture:
=======================
This architecture contains two types of programming they are 
	1. set of client side programming and
	2. set of server side programming.
						ex:google.
b. 3-tier architecture:
=======================
This architecture contains 3 types of programming they are 
	1. set of client side programmes 
	2. set of server side programmes 
	3. set of database softwares 
	ex: yahoo, gmail, ATM based apps.
c. n-tier architecture:
=======================
This architecture contains the following programmes
	1. set of client side programmes 
	2. set of fire wall programmes
	3. set of server side programmes 
	4. set of database softwares  
ex: 
----
 every 3-tier apps converted into n-tier apps adding a new layer called fire wall.

*History of java (James Gosling)
*Features of java
	1. Simple 
	2. platform independent
	3. architectural neutral 
	4. portable
	5. Multithreaded 
	6. networked 
	7. distributed 
	8. high performance
	9. highly interpreted 
	10. Robust (Strong)
	11. Dynamic 
	12. Secured 
	13. Oopl(object oriented programming language)

installation:
==============
step 1 : click on .exe file --->next button --->finish.

creating the path:
==================
open installation folder then select up to bin folder.
copy the up to bin folder location
	next ---->right click on my pc---> click on properties
	--->advanced system settings
	--->click on environment variables
	--->if you have path folder click on edit button 
	--->if you don't have path folder click on new button
	---> variable name is "path"
	---> variable value is "paste here up to bin folder"
	---> click on ok up to back initial position.
How to check java is there or not in your system?
sol: open cmd type java and then enter you will get java doesn't exist or any error
if java is there you will get some files.

how to check the version of java?
sol: "java -version" then enter 

how to check the compilation version?
sol: "javac -version" then enter.

how to check the path by using cmd?
sol: "echo %path%"

Java versions:
==============
JDK Alpha and Beta (1995)
JDK 1.0 (23rd Jan, 1996)
JDK 1.1 (19th Feb, 1997)
J2SE 1.2 (8th Dec, 1998)
J2SE 1.3 (8th May, 2000)
J2SE 1.4 (6th Feb, 2002)
J2SE 5.0 (30th Sep, 2004)
Java SE 6 (11th Dec, 2006)
Java SE 7 (28th July, 2011)
Java SE 8 (18th March, 2014)

Definition of byte code:
=======================
Byte code is a set of optimised instructions generated by java compilers using compilation phase and the nature of the byte code is much powerfull than pointer code of c, c++ languages.

Definition of JVM(Java virtual machine):
=======================================
JVM is one of the programme developed by sun micro systems developers available as a part of java software and whose role is reading the line by line of byte code and converting into native 
understanding format of OS.

	Hence byte code is OS independent and JVM is OS dependent.

Definition of JIT(Just In Time compiler):
========================================
JIT is the programme developed by sun micro systems developers as part of JVM and whose role is to speed up interpretation phase by reading the entire section of the byte code and a converted into native understanding format of OS.

conclusion: java is one of the compiler and interpretation based
----------- programming language.

Garbage collector:
=================
garbage collector is one of the system background java programme which is running along with our regular java programme and whose role is to collect un used memory space. for improving the performance of java based apps.

Data types :
===========
The purpose of data types is that to store the input of the programming in the main memory of the computer by allocating sufficient amount of memory space.

in all the programming languages data types are classified into 3 types those are

1. Fundamental / built in / predefined data types 
2. Derived data types
3. programmer / user defined / secondary defined / custom / referential defined data types.

Fundamental Data types:            
======================
Integer data types
Float data types
Character data types
Boolean data types


* Integer data types:
=====================
1. byte size  = 1 2^8.  1 Byte = 8 bits.
2. short size = 2 2^16
3. int size = 4   2^4*8
4. long size = 8   2^8*8

* Float data types:
===================
1. float size = 4  2^4*8
2. double size = 8 2^8*8

* Character data type:
========================
A character is an identifier enclosed within single quotes
ex:('A') ('B').......valid
    ('java') ('IUBAT').............invalid

* Boolean data types:
=====================
the purpose of this data type is to store ------ values

operators in java:
=================
Unary	postfix	expr++ expr--
	prefix	++expr --expr +expr -expr ~ !
--------------------------------------------------
Arithmetic	multiplicative	* / %
		additive	+ -
--------------------------------------------------
Shift	shift	<< >> >>>
Java Left Shift Operator:
=========================
The Java left shift operator << is used to shift all of the bits in a value to the left side of a specified number of times.
Java Right Shift Operator:
=========================
The Java right shift operator >> is used to move left operands value to right by the number of bits specified by the right operand.
--------------------------------------------------
Relational	comparison	< > <= >= instanceof
		equality	== !=
--------------------------------------------------
Bitwise	bitwise AND	&
bitwise exclusive OR	^
bitwise inclusive OR	|
--------------------------------------------------
Logical	logical AND	&&
	logical	OR	||
---------------------------------------------------
Ternary	ternary	? :
---------------------------------------------------
Assignment	assignment = += -= *= /= %= &= ^= |= <<= >>= >>>=
---------------------------------------------------
Control statements:
===================
Java If-else
Java Switch
Java For Loop
Java While Loop
Java Do While Loop
Java Break
Java Continue
Java Comments


*developing the methods in java:
================================
1. method taking the values and returning the values
2. method not taking the values and not returning the values
3. method taking the values and not returning the values
4. method not taking the values and returning the values

 Method overloading:
=====================
Here method is said to be over loaded if and only if method name is same but its signature is different.
	
	Signature represents the following points
1. no.of parameters 		||
2. type of parameters 		||at least one thing must be 
3. order of parameters 		||different 

ex:
a. sum(int a)
b. sum(int a, int b)
c. sum(float f, int a)

Method overriding:
=================
Method overriding is nothing but method name is same but method body is different.

ex:
public void disp()
{
	sop("hello");
}
public void disp()
{
	sop("JAVA");
}

static and non-static(instance) data members and methods:
========================================================

BootStrap ClassLoader:
=====================
A Bootstrap Class loader is a Machine code which kickstarts the operation when the JVM calls it. It is not a java class. Its job is to load the first pure Java ClassLoader. Bootstrap ClassLoader loads classes from the location rt.jar. Bootstrap ClassLoader doesnÕt have any parent ClassLoaders. It is also called as the Primordial ClassLoader.

Extension ClassLoader:
=====================
 The Extension ClassLoader is a child of Bootstrap ClassLoader and loads the extensions of core java classes from the respective JDK Extension library. It loads files from jre/lib/ext directory or any other directory pointed by the system property java.ext.dirs.

System ClassLoader: 
===================
An Application ClassLoader is also known as a System ClassLoader. It loads the Application type classes found in the environment variable CLASSPATH, -classpath or -cp command line option. The Application ClassLoader is a child class of Extension ClassLoader.

Note: The ClassLoader Delegation Hierarchy Model always functions in the order Application ClassLoader->Extension ClassLoader->Bootstrap ClassLoader. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then Application ClassLoader.



oops features / principles / concepts:
=====================================
in s/w development to develop any real time project we need to choose a language or technology and it can satisfy the principles of procedure orientation or object orientation in other words we have two types of programming languages they are 
popl(procedure orientated programming language) and 
oopl(object oriented programming language)

procedure oriented programming language:
=======================================
ex: c, cobal, 8086, pascal, visual basic, perl etc.
in real time popl are used for developing the projects of system s/w and apps s/w but industry is highly recommended popl not to use to develop distributed apps(internet s/w). because of the following limitations 

Limitations of popl:
====================
* popl posses platform dependancy.
* in popl the data is visiting b/w in client and server side apps in the form of plain text but not in the form of cypher text or encrypted format.
* in popl the data is un secured because it is visiting in the form of plain text.
* in popl the data is visiting b/w client and server side apps in the form of byte by byte. and it leads to poor communication.
* in popl the data is around functions.
to overcome the above limitations of popl industry is to recommended to use those programming languages which will satisfy oops principles. 
========================================
object oriented programming language:
-------------------------------------
ex: c++ , java , .net , ruby and oracle8 onwards. 

Benefits of oopl in development of distributed apps(JAVA):
=========================================================
* This languages posses platform independency.
* the data is visiting b/w client and server side apps in the form of cypher text or encrypted format.
* by default oopl apps are high secured .
* the data is visiting b/w client and server side apps all at ones and results in effective communication.
* in oopl related apps the data is around objects.
in order to say a programming language is object oriented it has to satisfy object oriented principles and they are classified into 8 types. 

Oops features or concepts:
=========================
1. class
2. objects 
3. data abstraction
4. data encapsulation
5. inheritance
6. polymorphism
7. dynamic binding 
8. message passing
	
	The above oops principles are common for all object oriented programming languages but their syntaxes/ implementations are varying from one oopl to another oopl.

class:
======
1. the purpose of classes concept is to develop programmer user defined data types. programmer defined data types allows to store multiple values either are same type or different types or both the types in single variable. 
2. to develop programmer defined data types with classes concepts we use a keyword called "class".
3. programmatically each and every class name is treated as programmer defined data type(P.D.D.T).
4. each and every java programme 1st starts with a concept of class i.e without classes concept we can't develop a meaningful apps.

Definition of a class in java:
===============================
1. the process of binding data members and associated methods 
in a single unit is called class. (or)

	a class is a collection of data members and methods.
2. data members of a class are also known as properties or attributes or fields where as methods are also known as accessories or behaviours.

**when ever we define a class memory space is not created for data members and methods or a class. but memory space is created for the data members and methods of a class when we create an object.
hence classes definition contains logical existence. where as an object contains physical existence.

fig: class diagram.

Object:
=======
we know that when ever we define a class memory space is not created for the data members and methods but whose memory space is created when we create an object.
1. in other words to enter the values for the data members of a class first we need to create an object.
2. to create an object there must exist in class definition otherwise we get compile time error.
3. without object creation it is not possible to perform any data processing.

=================================
Definition of a object in java:
=================================
1. instance of class is called an object (instance is nothing but allocating sufficient amount of memory space for data members and methods of a class)
2. each and every class variable is called object.
3. each and every grouped item is called object.
	(a grouped item is an variable which will hold similar type of values plus different type of values)
4. all the real world entities are called objects. 
	(type of pens, type of cars etc.)
5. blue print of a class is known as object.

creating an object in java:
==========================
creating an object in java is nothing but allocating the memory space for data members and methods of a class by following dynamic memory allocation with the help of "new" operator.

internal functions of new operator:
==================================
1. it allocates suitable memory space for data members and methods of a class.
2. it takes an address / reference of a loaded class place it into L.H.S variable i.e object name. 

	out of many ways of creating an object in java with new operator we can create an object by using the following syntaxes.

<class name> <obj name> = new <classname()>; 


=================================
dynamic values using cmd:
=============================
Technical description on print and println methods:
==================================================
1.Here println() and print() are the two predefined overloaded instance methods in PrintStream class.
2. To access println and print methods we need an object of PrintStream class.
3. An object of PrintStream class called out is created as the static data member in an another predefined class called system, hence to access println and print methods we must use the following statements 
	
	System.out.println(); it will print the data line by line.
	System.out.print(); it will print the data on same line.

Method chaining:
================
The process of establishing the communication between multiple methods for performing some operations is called method chaining 

ex: write a java programme which illustrate the concept of method chaining.

Converting string data into fundamental data:
=============================================
we know that when ever we enter cmd line arguments to the java programme they are passing to the main method and available in the form of array of objects of string class. all string type data it's not possible to perform numerical operations hence programmatically it is desirable to convert numerical string type data into numerical fundamental type data.

Wrapper classes in java:
************************************************  
1.byte 		||
2.short		||
3.int			||
4.long			||
5.float			|| Fundamental Data Types 
6.double		|| ex: public static xxx parsexxx(String);
7. char
8.boolean		||
			||
*************************************************
Constructors in java:
=====================
Def: A constructor is one of the special member method which is automatically / implicitly called by jvm. during object creation time for placing our own values without placing default values. 

A.D of constructors:-
===================
when we write the java programming constructors we get the following advantages 
1. constructors eliminates in placing default values.
2. constructors eliminates in calling ordinary methods.
3. in other words the purpose of constructors is that to initialise the object.

Rules / characteristics / properties of constructors:
====================================================
1. constructors will be called by jvm automatically / implicitly when the object is created.
2. constructor name must be similar to class name.
3. constructors should not contain any return type eve void also.
 if we write any return type then the constructor is a treated as an ordinary method.
4. constructors are not static (because constructors are executing every time when ever an object is created).
5. in java programming constructors will not participate in inheritance because every constructor of the class is meant for initialising its own data members. 
6. the access modifier of the constructor may or may not be private.
	a. if the access modifier of the constructor is private then we can create object of an its class in the same class context but not in the context of other class context.
	b. if the access modifier of the constructor is not private then we can create an object of the corresponding class both in same class context and in other class context.

types of constructors:
=====================
in java programming we have two types of constructors they are default / parameterless / zero argument constructor and parameterised constructor.
1. default constructor.
2. parameterised constructor.
3. overloaded constructor. 
4. object parameterised constructor. 
===
*************************************************
Data encapsulation:
==================
The process of hiding the features (data members, methods and constructors) from external users is called data encapsulation this can be obtained practically by using "private" access modifier.
**************************************************
Data abstraction:
=================
The process of retrieving or extracting essential details without considering hidden details is called data abstraction.
===================================
logical coding:
***************************
this keyword:
=============
"this" is one of the implicit / keyword created by jvm and supplied to each and every java programmer for two purposes they are 
1. it always points to current class object.
2. when ever the formal parameters and data members of the class are similar then jvm will get ambiguity problem (no clarity b/w two multiple duplicates) in order to differentiate b/w formal parameters and data members of the class the data members of the class must be presided by this keyword.

note:
====
java programming never supports operator overloading but the aim of operator overloading can be implemented in java by the concept of methods. 

note:
=====
a method of java is not only returning predefined data types and predefined class names but it can also return user defined class names as return type.

Factory method:
===============
A factory method is one whose return type is similar to class name in which class it present.
	the purpose of the factory method is to create an object without using new operator. 

Factory methods are classified into two types they are 

	1. instance factory method.

	Test instanceOf(Test obj)
	{
		//logic	
	}
	2. static factory method.
	
	static Test instanceOf(Test obj)
	{
		// logic
	}

Inheritance:
===========
Aim: inheritance is one of the distinct principle of oops. whose basic aim is to build java app's with reusability. 

Def:The process of obtaining the data members and methods(features) from one class into another class.
1. The class which is giving the data members and methods is called Base class/Super class/Parent class.
2. The class which is taking data members and methods is called derived class/sub class/child class.
3. inheretance concept always follows logical memory management this memory management says features of base class existing derived class without taking any memory space and without taking any explicit memory space. in other words this memory management says feeling that base class features are existing in derived class without taking any logical memory space. 

* inheritance concept is also known as 
 --> sub classing or derivation or extendable classes or reusability. 

Advantages of inheritance:
==========================
if we develop any java app with the concept of inheritance then we get the following advantages 

1. app development time is less.
2. app memory space is less.
3. app execution time is less.
4. app performance is enhance(improved).
5. redundancy of the code is minimised.
6. we are able to get the slogan of java.

inheritance types/reusable techniques:
======================================
The patterns / models used by the programmer for obtaining the features of one class into another class are called inheritance types of inheritances.

1. Single inheritance 
2. multilevel inheritance 
3. hierarchy inheritance
4. multiple inheritance
5. hybrid inheritance

inheriting the features of base class into derived class:
========================================================
1. in order to inherit the features of base class(BC) into derived class (DC) we use the following syntax.

Syntax:
======
	class <class name-2> extends <class name-1>
	{
		variable declaration
		method declaration
	}
explanation:
============
<class name-1> and <class name-2> represents name of the base and derived classes.

* extends is a keyword used for inheriting the features of base class into derived class plus it provides richest functionality to derived class. 

* Rule: in java programming, one derived class can extends only one BC. because java programme never supports multiple inheritance  through the concept of classes but it can be supports through the concept of interfaces.

* when we create an object of bottom most of derived class first we get the memory space for data members of TBC, second we get the memory space for data members of intermittent(intermediate) BC and last we get the memory space for BDC. Hence in the BDC all the features of top most base class and IBC are available logically.

Types of relationships in java:
===============================
The purpose of relationships is that how to use the features of one class into another class.
in java programming we have 3 types of relationships they are

	a. IS - A relationship
	b. HAS - A relationship
	c. uses - A relationship

1. IS - A relationship:
======================
in this relationship one class obtains the features of another class with the concept of inheritance by using extends keyword.

ex: class A
	{
	}
    class B extends A
	{
	}
  The limitation of is-a relationship is that unable to eliminate ambiguity problems in multiple inheritance. 

2. HAS - A relationship:
=======================
in this relationship an object of one class is created as a data member of in an another class.
	
ex: class C 
	{
	}
    class D
	{
	  C c = new C();
	} 
Here the relationship b/w C and D is "has-a" relationship. has-a relationship always follows physical memory management. the advantage of has-a relationship is that eliminating the ambiguity problems which are occurring in multiple inheritance.

uses-A relationship:
===================
a method of one class is using an object of another class.

ex:
	class A
	{
	}
	class B 
	{
	  void disp()
	   {
		A a = new A();
	   }
	}
*uses-A  relationship also follows physical memory management. 

*** Polymorphism:
================
* it is one of the distinct principle of oops.

*Definition of polymorphism: the process of representing "one form in multiple form is known as polymorphism".

in the definition of polymorphism:

* one form represents original method.
* multiple forms represents overridden methods.
* if forms is nothing but state of existence of method.

polymorphism is one of the principle but not programming concept. all the object oriented programming languages will follow / implement polymorphism principle by using different concepts present in the oopl. in java programming the polymorphism principle can be implemented by using two concepts they are 

1. method overriding 
2. method overloading 
we have two types of polymorphism they are 
1. static/compile time polymorphism
2. Dynamic/run time polymorphism
java always follows Dynamic polymorphism but not static polymorphism due to its limitations. 
* we use the polymorphism concept for developing BL in the form of dependant classes. 

Dynamic binding:
===============
1. it is also one of the distinct principle of oops.
2. Dynamic binding always says don't create the object of derived classes but always create an object of base class.
3. Dynamic binding principle is always used for executing polymorphism based applications.

Definition of dynamic binding:
==============================
The process of binding appropriate versions (overridden methods) of derived classes which are inherited from base class with base class object is called Dynamic binding. 
whenever we use dynamic binding for executing polymorphism applications JVM internally consider the following points 

1. what type of object.
2. what type of reference object contains.

in other words if we create object indirectly by following dynamic binding principle JVM will consider the above two points.

JRE:(JAVA RUN TIME ENVIRONMENT)
JDK:(JAVA DEVELOPMENT KIT)
COMPILER:(CONVERTS A.JAVA FILE TO A.CLASS)
JIT:(just in time compiler)
JVM:(java virtual machine)
JAR FILE:(java archieve)
JAVAC:(compilation command)
JAVA:(run command)

concrete class or normal class:
==============================
1. a concrete class always contains fully defined methods.
2. defined methods of a class are also known as concrete / implemented methods.

ex:
==	class Test
	{
	  void show()
	   {
		sop("test show");
	   }
	}
here test class containing one method and whose object can be create directly 
	Test t = new Test();
	t.show();

in general ones the class is concrete whose object can be create directly.

the purpose of concrete class is always to deal with specific requirements which are suitable to one programmer and it's not to deal with common requirements. 
either in the form of independent class or dependent classes. 

if we choose concrete classes to deal with common requirements then such apps will get the following problems 

1. Apps takes more memory spaces
2. Apps takes more execution time
3. less performance of apps.

to overcome the above problems we use abstract classes concept.

Abstract classes:
================
An abstract class is one which contains some defined methods and undefined methods.

the purpose of using AC's is to deal with common requirements 

undefined methods of abstract class are known as abstract methods / un implemented methods.

Abstract methods:
================
abstract methods only declaration / prototype but it never contains body definition. 

to make undefined methods as abstract methods the declaration of the undefined methods must be preceded by abstract keyword.

syntax:
=======    abstract class <class name>
	{
	   abstract void add();
	   abstract void show();
	   abstract void draw();
	}
 abstract method kwd follow JVM internally two points 
a. what a method can do? 
   but it never gives 
b. how a method can be done?

Limitations of abstract classes:
================================
1. abstract classes never participates in multiple inheritance.
2. abstract classes provides only common reusable features but    they never provides universal common reusable features.
3. abstract classes provides partially less execution time. but    not able to provide completely less execution time. because an    abstract class contains both define and undefined methods. 

to overcome above limitations of abstract classes we use another concept called interfaces.

interfaces:
==========
need / advantages of interfaces:
================================
if we develop any java apps with the concept of interfaces then we get the following advantages. 

a. interfaces participates in multiple inheritance 
b. interfaces provides universal common reusable features
c. interfaces related apps provides completely less execution time. 

programmatically interfaces concepts is used for developing universal user defined data types.

to develop user defined data type with interfaces concept we use a keyword called "interface".

programmatically each and every interface name is treated as Universal User Defined Data Types.

Definition of interface:
========================
An interface is a collection of public static final xxx data members and public abstract methods.

here xxx represents 1st x is data type
		    2nd x is variable name
		    3rd x is variable value.
			(or)
an interface is a collection of universal common reusable data members and universal common reusable methods.

syntax:
======= 	interface <interface name>
		{
		  variable initialise/ cum declaration
		  
		  methods declaration.
		}

inner / nested interfaces:
==========================
we know that normal interfaces contains multiple abstract methods if any implement class of normal interface implements the normal interface. then implementation class programmer needs to implement all the abstract methods even though they interested in one method this approach leads to two limitations they are

1. forcing to implementation class programmer define all uninterested methods along with interested methods.
2. takes more amount of time to develop apps.

to overcome the above limitations of normal interfaces we use nested / inner interfaces concepts.

Definition of inner / nested interface:
=======================================
if we define an interface 'Y' inside the definition of another interface 'X' then interface Y is called inner nested interface.

definition of containership:
===========================
the process of defining one interface definition inside the definition of another interface is called containership.

Functional interface:
====================
Functional interface concept is available from jdk 1.8 version onwards an interface is said to be functional interface if and only if it contains only one abstract method.

in real time apps most of the time functional interface methods of implemented in anonymous inner classes.

Definition of anonymous inner class:
===================================
an anonymous inner class does not contain any name explicitly in java programme and it is given by java environment and it contains implementation of abstract methods functional interfaces. 

Q write a java programme which illustrate the concept of functional and anonymous inner classes?

ex: interface Sum
	{
	  void sum();
	}
    interface Sub
	{
	  void sub();
	}
class Test
{
  public static void main(String[] args)
   {
	Sum sm  = new Sum()
	{
	  int a, b, c;
	  public void sum()
	  {
	    a = 10;
	    b = 20;
	    c = a+b;
	   sop(c);
	  }
	}; sm.sum();
	new Sub() // nameless object creation
	{
	  int a,b,c;
	  public void sub()
	  {
	    a = 10;
	    b = 20;
	    c = a-b;
	    sop(c);
	  }
	}.sub();
   }
}
in the above programme the functional interfaces sum()  is implemented in one of the anonymous inner class called Test$1

similarlly the functional interface sub() is implemented in one of the inner class called Test$2. 

Marker / tagged interface:
=========================
The marker interfaces doesn't contain any methods explicitly (implicitly methods are existing which are jvm dependent overridden methods) and it provides run time behaviour to its sub classes.

ex: java.lang.Cloneable
    java.io.Serializable
    java.rmi.Remote       etc.



*.data conversion techniques
*.Auto boxing and unboxing
*.access modifiers


packages:
========
definition of API:
=================

type of packages:
=================
in java programming we have 3 types of packages they are 
1. predefined / built in packages
2. user defined packages/ programmer define packages/ custom defined packages
3. Third party packages

types of predefined packages:
============================
1. J2SE
2. J2EE
3. J2ME 

list of predefined packages in J2SE:
====================================
as a part of J2SE we have 8 essential packages they are 
1. java.lang.*:
==============
it is one of the predefined package and whose purpose is providing language functionality / facilities / services to each and every java programme. some of the language facilities are 

a. displaying the result of the java programme on the console.
b. accepting the command line arguments.
c. data conversion
d. obtaining the garbage collection facility
e. development of multithreading apps etc.

this package is default package. 

2. java.awt.*(abstract windowing tool kit):
===========================================
3. java.awt.event.* :
=====================
4. java.io.*:
=============
The purpose of this package is to achieve the data persistency in the form of files.

definition of stream:
=====================
the flow of data between main memory and secondary memory in the form of bytes and bits is called stream.

5.java.applet.*:
================
only one class in this package java.applet.Applet

6. java.net.*:
==============

7. java.util.*:
==============

8. java.text.*:
===============

=====================
Exception handling
=====================
The aim of exception handling is to build Robust application (Strong apps).

in any programming language when we write a programme we get 3 types of errors they are
	---->Compile time errors
	---->Logical errors
	---->Run time errors

Compile time errors:
===================
This errors occurs at compilation time due to syntaxes are not followed by programmers.
This errors solved by programmers at development level.

Logical errors:
==============
This errors occurs during execution or runtime due to misinterpretation or wrong representation of logic.
this errors always generates in consist or wrong results and they must be solved by programmer at development level.

Runtime errors:
===============
This errors occurs at runtime / execution time due to invalid input entered by application user at implementation level (an application being used by client organisation) 
if we develop real world project with any kind of language or technology and at the time of implementation level. 
if the application user entered invalid input then we get runtime errors and they generates system error messages.
which are understandable by programmer but not application user. 
which is not a recommended process. 
industry is highly recommended to generates user friendly error messages .
where application user can understand what mistake committed at the time of entering the input. 
The languages like  c/c++/pascal/cobol etc and whose applications are treated as weak.
because this languages are not containing exception handling facility.
The languages like java and whose applications are treated as Robust. because java programming contains exception handling facility.

Points to be remember:
======================
1. when the apps user enters invalid i/p then we get run time errors.
2. Runtime errors of any programme gives system/technical error messages.
3.Definition of exception: Runtime errors of java programme are known as exception.
4.exceptions always generates system error messages.
***5. when ever an exception occurs in java programme, programme execution is abnormally terminated CPU controls comes out of the programme flow and JVM generates system error messages. which is not a recommended process. 
6. industry is highly recommended to generate user friendly error messages instead of generating system error messages by using exception handling concept.

Exception Handling:
==================
The process of converting system error messages into user friendly error messages.
step1.
apps user entered invalid inputs then you will get SEM.
step2.
SEM are giving input to the java programmer he will handle the exceptions.
step3.
user friendly error messages 

Handling the exceptions: 
=======================
Handling the exceptions is nothing but converting system error messages into user friendly error messages.
As the part of handling the exceptions we have five keywords they are
1. try block
2. catch block
3. finally block
4. throws
5. throw

syntax for handling the exceptions:
==================================
try
{
	Block of statement(s) which are causing 
	exceptions at runtime
}catch(type of exception1 obj1)
	{
	block of statements which will generates 
	user friendly error messages.
	}
	catch(type of exception2 obj2)
	{
	block of statements which will generates 
	user friendly error messages.
	}

	catch(type of exception n objn)
	{
	block of statements which will generates 
	user friendly error messages.
	}
finally 
{
	block of statements which will
	executes compulsorly.
}

try block:
==========
1. This is the block in  which we write the block of statements which will provide exceptions at runtime. in other words this block always contains set of problematic statements which will generate exception at runtime this block is also known as exceptions monitoring block.

2.when ever an exception occurs in try block jvm control comes out of the try block and jvm will execute appropriate catch block.

3. after executing an appropriate catch block jvm control never goes to try block to execute the rest of the statements even through we use return statement in catch block.

4.programmatically each and every try block must be followed by catch block otherwise we get compile time error in other words intermediate statements are not permitted in between try and catch block 

5.each and every try block must contain at least one catch block and industry is highly recommended to write multiple catch blocks for generating multiple user friendly error messages for making java applications robust.

6. one try block can contain another try block i.e nested try blocks can be permitted.

Catch block:
===========
1. This is used for providing user friendly messages by catching system error messages. 
(writing catch block is nothing but handling exceptions)

2. In the catch we must declare an object of the appropriate execution class and it will be internally referenced JVM whenever the appropriate situation taking place.

 3. If we write ‘n’ number of catch’s as a part of JAVA program then only one catch will be executing at any point. 

4. After executing appropriate catch block even if we use return statement in the catch block the control never goes to try block. 

Finally block:
=============
1. This is the block which is executing compulsory whether the exception is taking place or not.

2. This block contains same statements which releases the resources which are obtained in try block (resources are opening files, opening databases, etc.).

3. Writing the finally block is optional

4. it is highly recommonded to the java programmer for finally block for one programme.

5. in some circumstances in the finally block one can write a try and catch block.

Conclusion:
***********
case 1:
=======
if exception occurs then
**************************
* A part of try block will execute 
* appropriate catch block will execute
*finally block will execute if we write.

case 2:
=======
if exception doesn't occurs then
*********************************
* the complete try block will execute 
* finally block will execute if we write 

Throws:
======
This is the keyword which gives an indication to the calling function to keep the called function under try and catch blocks.

Syntax: 
=======
<Return type> method name (number of parameters if any) throws type of exception1,type of exception2,………type of exception;

Number of ways to find details of the exception:
================================================
In JAVA there are three ways to find the details of the exception. They are using an object of 
1.java.lang.Exception class object, 
2.using public void printStackTrace method
3.and using public string getMessage method. 
 
i. Using an object of java.lang.Exception:
==========================================
An object of Exception class prints the name of the exception and nature of the message. 
For example:
 try 
{ 
 int x=Integer.parseInt ("10x"); 
} catch (Exception e) 
{ 
System.out.println (e); // java.lang.NumberFormatException :
			 for input string 10x 
} 

Using printStackTrace method: 
============================
This is the method which is defined in java.lang.Throwable class and it is inherited into java.lang.Error class and java.lang.Exception class. This method will display name of the exception, nature of the message and line number where the exception has taken place. 
 For example: 
try 
{  
	......; 
	 int x=10/0;  
	......;
 } catch (Exception e)
 {  
	e.printStackTrace (); // java.lang.ArithmeticException :  / by 	zero :  at line no: 4 
} 

Using getMessage method: 
========================
This is also a method which is defined in java.lang.Throwable class and it is inherited into both Error and Exception classes. This method will display only nature of the message. 
For example: 
try 
{  
	......;  
	int x=10/0;
	  ......; 
} catch (Exception e) 
{  
	System.out.println (e.getMessage ()); // / by zero 
}        nature of the message 

Development of user defined/ programmer defined exceptions:
***********************************************************
User defined exceptions are those which are developed by java programmers available as a part of java project whose role is to deal with common problems.

problems:
========
1. trying to enter -ve salary to an employee.
2. attempting to withdraw excess amount than 	existing.
3. attempting to enter wrong pin in atm based apps.
4. trying to enter invalid user name and password.
5. trying to enter digits in a name.
6. trying to enter alphabets in the cost / time / distance.

in general if any common problems occur in our project then it is recommended to the java programmer developed programmer defined exception sub classes to terminate the programme execution abnormally by giving user friendly error messages.

Steps / guidelines for developing programmer/ user defined exception sub classes:
==================================================
what are all the guide lines are followed by sun micro systems developers for development of predefined exceptions same guide lines will be followed by java programmer. for development of user defined exceptions.

1. choose an appropriate package for placing user exception subclass for common access and ensure that the package must be first executable statement.

2.choose an appropriate user defined class name and ensure that whose modifier must be public.

3. what ever class is selected in step number (2) it must extends java.lang.Exception or RuntimeException for inheriting the capabilities of exception handling. to terminate the programme execution obnormally when the application user enters invalid input. Hence step 2 class is called exception sub class.

4.Each and every userdefined exception sub class must contain single parameterised constructor by taking string as a parameter here string parameter represents nature of messages.

5. Each and every userdefined exception subclass parameterised constructor must call single parameterised either java.lang.Exception or RuntimeException by using super(msg); here is a string variable.
(the reason for writing super (msg)) is that specific exception occurs in java programme and if we are not handling the specific exception related constructor must call their super class constructors.

No.of phases required for developing user defined exception based applications:
=======================================================

1. Development user defined exception subclass
2. Development user defined common classes
3. Development of specific classes

phase 1: Development of userdefined exception subclass:
===================================================
to develop user defined exception sub classes we follow 5 steps (see previous 5 steps)

Ex: NsalException and PsalException

phase2: Development of userdefined common classes:
=================================================
This phase related classes deals with common requirements which are suitable for multiple programmers and this classes makes use of user defined exception sub classes and predefined exception sub classes

ex: validate each emp salary 

in xxxx company emp decidesal method is called userdefined common exception method and it must be accessed within try and catch blocks.

phase3: development of user defined specific classes
===============================================
This classes deals with specific requirements of the programme and this classes makes use of user defined and predefined common classes and handle the exceptions.

ex: code for check salary of emp and check user login validations 

throw Keyword:
=============
throw keyword is used to throw an exception explicitly. Only object of Throwable class or its sub classes can be thrown. Program execution stops on encountering throw statement, and the closest catch statement is checked for matching type of exception.

Syntax :
=======
throw ThrowableInstance

Creating Instance of Throwable class:
===================================
There are two possible ways to create an instance of class Throwable,

1.Using a parameter in catch block.
2.Creating instance with new operator.

new NullPointerException("test");

This constructs an instance of NullPointerException with name test
*********************************phone*************
class PhoneNotValidException extends RuntimeException {
    public PhoneNotValidException(String message) {
        super(message);
    }
}

public void validatePhoneNumber(String phone) {
    final String str = "^(1\\-)?[0-9]{3}\\-?[0-9]{3}\\-?[0-9]{4}$";
    if (!Pattern.matches(regexStr, phone)) {
        throw new PhoneNotValidException(phone);
    }
}
**************************************
Re - trowing the excepiton:
===========================
First method is throwing the exception to second method. second method is throwing first method related exception to third method. with respect to second mehtod and first method related exception is called re - throwing / deep throwing exception.

************************************
		:Multi Threading:
************************************
1. Aim of multi threading.

ans:Multithreading in java is a process of executing multiple threads simultaneously. The aim of multithreading is to achieve the concurrent execution.

2. What is thread.

Thread is a lightweight components and it is a flow of control. In other words a flow of control is known as thread.

3. The purpose of thread is executing the logic of the java programme which is written in the form of user defined methods concurrently.

4. if a java programme contains multiple threads then it is called multithreaded. 

5. the languages like c, c++, pascal, Cobol etc are treated as single threaded modelling languages. because there execution environment contains single flow of controls. provides sequential execution takes more execution time. not containing any library for development of thread based application.

6. The languages like java and .net are treated as multi threaded modelling languages because there execution environment provides multiple flow of control. concurrent execution, takes less execution time. and containing an effective API for development of thread based applications.

7. in java programming we use the following API for development of multi threading apps.

java.lang.Thread(class)
java.lang.Runnable(interface)

8. when ever we write any type of java programme there exist two types of threads they are
	
	a.foreground thread / child thread
	b.background thread / parent thread
9. A foreground thread is always used for executing the logic of the java programme which is written in the form of user defined methods. a background thread is always used for monitoring the execution status of foreground thread(s).

10. by default there exist single FGT and BGT provides sequential execution. programmatically. a java programme can contain multiple FGTS and recommended to take single background thread for executing and monitoring concurrently.

11. the real time implementation of multi threading concept is that to develop real world server softwares. (apache tomcat, web logic BEa Systems, web-sphere IBM)etc. in other words most of the server software vendors developed the server softwares in java language with multithreading concept. 

12. hence multithreading concept of java is one of the specialised form of multi tasking of operating system.

Q. How do you justify each and every java programme is multithreaded.

Ans:1. when we execute the java programme logic of the java programme is executed by one of the thread and it is known as FGT.

2. Internally to monitor the execution status of FGT one more thread is created as BGT.

3. So a java programme is by default containing two threads hence by default every java programme is multithreaded.

Key Differences Between Process and Thread in Java:
===================================================
1.A process is an executing program whereas, the thread is a small part of a process.
2.Each process has its own address space whereas, the threads of the same process share the address space as that of the process.
3.In process based multitasking, more than two processes can run at the same time whereas, in thread-based multitasking, more than two thread can run at the same time.
4.Inter-process communication between two processes is costlier than inter-thread communication.
5.Context switching between two processes is expensive and limited as compared to context switching between two threads.
6.A process is also called the heavyweight task whereas, the thread is called lightweight task.
7.Multitasking over a process is not under the control of Java whereas, the Multitasking over multithreading is under the control of Java.
8.Components contained by a process its own address space, global variables, signal handlers, open files, child processes, accounting information. On the other hand, a thread contains its own register, state, stack, program counter.

Conclusion:
===========
If we look at the process and thread, the thread is a piece of code which requires the environment of the process to run smoothly.

Definition of address space:
===========================
it is an amount of temporary memory space created by os on stack memory for the execution of the method.

Definition of context switch:
============================
it is the mechanism of switching the control of cpu from one address space to another address space. 
*** for the best application development context switch must be less.

Definition of CPU burst time:
============================
it is an amount of time required by the thread from the device CPU for executing the java programme which is return in the form of methods. CPU burst time decided by OS when it is about to execute.

sharp note:
==========
when we execute any thread based apps it will be considered as process based apps in main memory and it which a main process will be created main process interns creates subprocess (known as forking) in java programming point of view the main process is called FGTS. 

Fig:2

where as a process based apps will be considered as process based apps but not thread based apps because during its execution their exist single flow of control.

Fig:1

3. Thread life cycle.
=====================
	The different breaking points or stages occurring in the execution process of the java programme by the thread are known as states of a thread or life cycle of a thread. in java programming states of a thread is 5 stages

a. new state:
	in this state thread is created and it is about to enter into main memory.
b. ready state:
	in this state thread is enter into main memory, memory space is created for the thread and first time waiting for the cpu.
c. running state:
	in this state the thread is under the control of CPU or as long as the thread is under the execution state of the thread is runnable.
d. halted or dead state or terminated state:
==========================================
	in this state thread completed its total CPU burst time or thread has completed total execution it comes out from main memory and whose state is called halted.
e. waiting state.
================
	1. A thread is said to be in waiting state if and only if any of the following factors satisfied.
2.thread will come to waiting state for the remaining CPU burst time.
3.Making the currently executing thread to sleep for a period of time in terms of milli seconds.
4.suspending the currently executing thread .
5. making the currently executing thread to wait with some amount of time.
6. making the currently executing thread to wait without time. 
7. joining the threads.

Hence: 
======
new state and halted states are called out memory states and whose execution status is false. where as ready, running and wait states are called in memory states. and whose execution states is true.

Q How do you justify "Threads of java executes concurrently".

	Let us assume if thread of java executes with the difference of hours, minutes and seconds then it will be consider as slowest execution called sequential execution. and it is not a designed strategy in multi threading.
	if the threads of java programming executes with the difference of milli seconds of time then such type of execution will be consider as fastest execution called concurrent execution. this is the implicit designed strategy in the multi threading of java. hence in multi threading all threads are executing internally with the difference of milli seconds of time by following Round Robin algorithm concurrently.

creating a thread:
=================
We know that a flow of control is known as thread and it is meant for executing the logic of the java programme which is written in the form of methods concurrently in java programming we have two ways to create a thread they are 
	1.By using java.lang.Thread (class).
	2.By using java.lang.Runnable(interface).

1. By using java.lang.Thread:
=============================
We can create an object of java.lang.Thread class in 3 ways.
a. by using new operator.
	Thread t = new Thread();
b. by using factory method.
	Thread t1 = Thread.currentThread();
C. by using an object of java.lang.Thread class 
	class Th1 extends Thread
	{
	Th1 t2 = new Th1();
	}
 Here t2 is object of Th1 and Th1 is the sub class of java.lang.Thread . and indirectly t2 is an object of java.lang.Thread class.	
	
**********************************************
Profile of Thread Class:
***************************** 
Data members:
============
1.public static final int MAX_PRIORITY(=10)
2.public static final int NORM_PRIORITY(=5)
3.public static final int MIN_PRIORITY(=1)

	The above data members are called thread priority modifiers this priority modifiers makes the JVM adn cpu to understand which thread to execute first, second and third. 
the default priority of thread is NORM_PRIORITY.

Constructors:
**************
1. Thread():
 With this Constructor we can create an object of the Thread class whose default thread name is Thread-0. 
For example: 
	Thread t=new Thread (); 
	System.out.println (t.getName ());// Thread-0

2. Thread(String):
 This Constructor is used for creating a thread and we can give the user specified thread name. 
For example: 
	Thread t=new Thread (“JAVA”); 
	t.setName (“JAVA”); 
	t.setPriority (Thread.MAX_PRIORITY); 
3. Thread(Runnable):
	 This Constructor is used for converting Runnable object into Thread object for entering into run method of Runnable interface by making use of start method of Thread class without giving thread name. 
4. Thread(Runnable,String)
	This Constructor is similar to above Constructor but we give thread name through this Constructor. 
 

instance methods:
***************************
1. public final void setName()
2. public final String getName()

	The above two methods are used for setting the name of the thread and getting the name from the thread respectively. 
ex: public final void setPriority(int)
    public final int getPriority()

3. public boolean isAlive()

*******************************************
4. public void run():
=====================
 Any JAVA programmer want to define a logic for the thread that logic must be defined only run () method. When the thread is started, the JVM looks for the appropriate run () method for executing the logic of the thread. Thread class is a concrete class and it contains all defined methods and all these methods are being to final except run () method. run () method is by default contains a definition with null body. Since we are providing the logic for the thread in run () method. Hence it must be overridden by extending Thread class into our own class. 
 
For example: class C1 extends Thread 
	{  
	public void run () 
	    {	
		 ………………………;
		 ………………………; 
	    
	    }
	 } 
 
5. public final void start():
=========================
  This is the method which is used for making the Thread to start to execute the thread logic. The method start is internally
 calling the method run(). 
 
For example: Thread t1=new Thread (); 
		t1.start (); 
		Thread t2=Thread.currentThread (); 
		t2.start (); 

6. public final void suspend():
	This method is used for suspending the thread from current execution of thread. When the thread is suspended, it sends to waiting state by keeping the temporary results in process control block.
	ex:t1.suspend()

7. public final void resume()
	This method is used for bringing the suspended thread from waiting state to ready state. When the thread is resumed to start executing from where it left out previously by retrieving the previous result from PCB. 
	
	ex:t1.resume()

8. public final void stop():
	This method is used to stop the execution of the current thread and the thread goes to halted state from running state. When the thread is restarted it starts executing from the beginning only.
9.public final void join() throws interuptedException:
	This method is used for making the fore ground threads to join together so that JVM can call the garbage collector only one time for collecting all of them instead of collecting individually.
 
10. public ThreadGroup getThreadGroup()	:
=======================================
ThreadGroup creates a group of threads. It offers a convenient way to manage groups of threads as a unit. This is particularly valuable in situation in which you want to suspend and resume a number of related threads.

The thread group form a tree in which every thread group except the initial thread group has a parent.
A thread is allowed to access information about its own thread group but not to access information about its thread group’s parent thread group or any other thread group.
	this method is used for obtaining the thread group information of fore ground thread .

 	ThreadGroup tg = t1.getThreadGroup();
	sop(tg);//[main, 10, system]

		main :default TGN given by JVM
		10 : MAX_PRIORITY
		System : garbage collector 

11. public Thread.State getState()
	This method is used for finding name of the state of thread and it is holding in the object of state class which is one of the inner class in the thread class 
	Th1 t1 = new Th1();
	    or 
	Thread t1 = new Thread();
	Thread.State ts = t1.getState();
		sop(ts);
********************************************** 
static methods:
**********************************************
12. public static final Thread currentThread()
	it si one of the static factory method the purpose of this method is obtaining the threads which are by default running.
	Thread t = Thread.currentThread();
	sop(t);// [main, 5, main]
	main: FGT , 5 NORM_PRIORITY, TGN
	t.setName("java");
	sop(t);[java, 5, main]

13. public static final void sleep(long msec)

Daemon thread :
==============
Daemon threads are used for background supporting tasks and are only needed while normal threads are executing. GC thread is a daemon thread. A user thread is a thread that is created by the application (user), and, in most cases, a daemon thread is created by the Java VM to serve the user threads.
	
	Daemon thread is a low priority thread (in context of JVM) that runs in background to perform tasks such as garbage collection (gc) etc., they do not prevent the JVM from exiting (even if the daemon thread itself is running) when all the user threads (non-daemon threads) finish their execution.

14. internal flow of threads:
=============================
Sol: when ever we create a multi threading apps there exist n number of fore ground threads it is mandatory to the java programmer to find internal flow of FGTs and the sequence of steps are given below.

1. java programme starts executing.
2. jvm creates thread group name (TGN) it always in main method.
3. TGN creates FGTs. FGTs Decides in run() method.
4. Thread group name dispatches fore ground threads to their respective run() methods. 
5. FGTs executes the respective run() methods and gives result to thread group name either one by one or all at ones.
6. thread group name receives result from FGT either one by one or all at ones.
7. TGN gives result to apps user / programmer either one by one or all at ones.
8. TGN collects and handover to GC. default one by one or all at ones. 
9. jvm collects TGN and handover to GC. 
10. java programme stops executing (because it doesn't contains any threads).

yield():
=======
Which will keep the currently executing thread into temporarily pass and allows other threads to execute.

What is race condition:
======================
A race condition is a situation in which two or more threads or
processes are reading or writing some shared data, and 
the final result depends on the timing of how the threads are scheduled.
Race conditions can lead to unpredictable results and subtle
program bugs. A thread can prevent this from happening by locking
an object. When an object is locked by one thread and another
thread tries to call a synchronised method on the same object,
the second thread will block until the object is unlocked.

**********************************************
Synchronization:
**********************************************
1. need of synchronization.
Whenever multiple threads are trying to use same resource than they may be chance to of getting wrong output, to overcome this problem thread synchronization can be used.

Definition: Allowing only one thread at a time to utilized the same resource out of multiple threads is known as thread synchronization or thread safe.

In java language thread synchronization can be achieve in two different ways.

1.Synchronized method
2.Synchronized block

Note: synchronization is a keyword in java.

1. thread synchronization methods:
=================================
  If any method is sharable for ‘n’ number of threads then make the method as synchronized by using a keyword synchronized.  In JAVA we have two types of synchronized methods. 
   
   a. synchronized instance methods
   b. synchronized static methods

a. synchronized instance methods:
================================
Synchronized Instance methods: If the ordinary instance method is made it as synchronized then the object of the corresponding class will be locked. 

Syntax: 
synchronized <return type> method name (method parameters if any) 
{
  Block of statements;
}

For example:
============
 class Account
 {  int bal=0;
  synchronized void deposit (int amt)
  {   bal=bal+amt;
   System.out.println (“CURRENT BALANCE = ”+bal);
  }
}
 b. synchronized static methods:
================================
If an ordinary static method is made it as synchronized then the corresponding class will be locked. 

Syntax:
 synchronized static <return type> method name (method parameters if any)
 {
  Block of statements;
 } 

Exp:
====
class Account
 {  
   static int bal=0;
synchronized static void deposit (static int amt)
  {
   bal=bal+amt;
   System.out.println (“CURRENT BALANCE = ”+bal);
  } 
 }

2. Synchronized block:
==================
This is an alternative technique for obtaining the concept of synchronization instead of synchronized methods

	Whenever we want to execute one or more than one statement by a single thread at a time(not allowing other thread until thread one execution is completed) than those statement should be placed in side synchronized block.

	When we inherit non-synchronized methods from either base class or interface into the derived class, we cannot make the inherited method as synchronized. Hence, we must use synchronized blocks. 

Syntax:
======
class  Class_Name  implement Runnable or extends Thread
{
     public void run()
     {
	synchronized(this)
	{
	.......
	.......
	}
     }
}
For example:
===========
interface BankOp
 {
  void deposit (int amt);
 } 

class Account implements BankOp
 {
  int bal=0;
  public void deposit (int amt)
  {
   synchronized (this)
   {    bal=bal+amt;
    System.out.println (“current value=”+bal);
   } 
 } 

ITC (Inter thread communication:):
===
  If two or more threads are exchanging the data is known as  thread communication. In inter thread communication, an output of one thread is given as an input to another thread. In order to develop inter thread communication applications we must make use of a class called java.lang.Object. 

fig:

Methods in java.lang.Object:
 1. public void wait (long msec)
 2. public void wait (long msec, int nanosec)
 3. public void wait ()
 4. public void notify ()
 5. public void notifyAll ()

	Methods 1 and 2 are used for making the thread to wait for some period of time.once the waiting time is over automatically the thread will come from waiting state to ready state. Method 3 is used for making the thread to wait without specifying waiting time. Method 4 is used for bringing a single waiting thread into ready state. Method 5 is used for bringing all the threads from waiting state to ready state.

Q.Develop producer consumer program by using inter thread communication

Deadlock:
=========
Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Deadlocks can occur in Java when the synchronized keyword causes the executing thread to block while waiting to get the lock, associated with the specified object. Since the thread might already hold locks associated with other objects, two threads could each be waiting for the other to release a lock. In such case, they will end up waiting forever.

Example:
========
public class MyDeadlock {
 
    String str1 = "Java";
    String str2 = ".NET";
     
    Thread trd1 = new Thread("My Thread 1"){
        public void run(){
            while(true){
                synchronized(str1){
                    synchronized(str2){
                 System.out.println(str1 + str2);
                    }
                }
            }
        }
    }
     
    Thread trd2 = new Thread("My Thread 2"){
        public void run(){
            while(true){
                synchronized(str2){
                    synchronized(str1){
                 System.out.println(str2 + str1);
                    }
                }
            }
        }
    }
     
    public static void main(String a[]){
        MyDeadlock mdl = new MyDeadlock();
        mdl.trd1.start();
        mdl.trd2.start();
    }
}
X